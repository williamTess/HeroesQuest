{"ast":null,"code":"import { MOOVE, ORIENTATION } from \"../type/enum\";\nconst getPrevCase = (current, hero) => {\n  let tmpHero = hero;\n  tmpHero.prevCase = current;\n  if (current.includes(\"T\")) {\n    if (current === \"T\") tmpHero.prevCase = \"0\";else {\n      const strNumber = current.slice(1);\n      const rest = +strNumber - 1;\n      tmpHero.prevCase = rest === 0 ? \"0\" : `T${rest}`;\n    }\n    tmpHero.treasure += 1;\n  }\n  return tmpHero;\n};\nconst changeOrientation = (move, currentOrientation) => {\n  let orientation = currentOrientation;\n  if (move === MOOVE.GAUCHE) {\n    if (currentOrientation === ORIENTATION.NORD) orientation = ORIENTATION.OUEST;else if (currentOrientation === ORIENTATION.SUD) orientation = ORIENTATION.EST;else if (currentOrientation === ORIENTATION.EST) orientation = ORIENTATION.NORD;else if (currentOrientation === ORIENTATION.OUEST) orientation = ORIENTATION.SUD;\n  } else if (move === MOOVE.DROITE) {\n    if (currentOrientation === ORIENTATION.NORD) orientation = ORIENTATION.EST;else if (currentOrientation === ORIENTATION.SUD) orientation = ORIENTATION.OUEST;else if (currentOrientation === ORIENTATION.EST) orientation = ORIENTATION.SUD;else if (currentOrientation === ORIENTATION.OUEST) orientation = ORIENTATION.NORD;\n  }\n  return orientation;\n};\nconst moveHero = (hero, currentMap) => {\n  let mapTmp = [...currentMap];\n  const {\n    position: currentPosition,\n    orientation: currentOrientation,\n    prevCase: currentPrevCase,\n    name\n  } = hero;\n  const defaultReturn = {\n    map: currentMap,\n    newHeroStat: hero\n  };\n  let newPrevCase;\n  let tmpHero = hero;\n  if (currentOrientation === ORIENTATION.NORD) {\n    if (!mapTmp[currentPosition.x - 1]) return defaultReturn;\n    if (![\"0\", \"T\"].includes(mapTmp[currentPosition.x - 1][currentPosition.y][0])) return defaultReturn;\n    mapTmp[currentPosition.x][currentPosition.y] = currentPrevCase;\n    tmpHero = getPrevCase(mapTmp[currentPosition.x - 1][currentPosition.y], hero);\n    mapTmp[currentPosition.x - 1][currentPosition.y] = name;\n    return {\n      map: mapTmp,\n      newHeroStat: {\n        ...hero,\n        position: {\n          x: currentPosition.x - 1,\n          y: currentPosition.y\n        }\n      }\n    };\n  } else if (currentOrientation === ORIENTATION.SUD) {\n    if (!mapTmp[currentPosition.x + 1]) return defaultReturn;\n    if (![\"0\", \"T\"].includes(mapTmp[currentPosition.x + 1][currentPosition.y][0])) return defaultReturn;\n    mapTmp[currentPosition.x][currentPosition.y] = currentPrevCase;\n    tmpHero = getPrevCase(mapTmp[currentPosition.x + 1][currentPosition.y], hero);\n    mapTmp[currentPosition.x + 1][currentPosition.y] = name;\n    return {\n      map: mapTmp,\n      newHeroStat: {\n        ...hero,\n        position: {\n          x: currentPosition.x + 1,\n          y: currentPosition.y\n        }\n      }\n    };\n  } else if (currentOrientation === ORIENTATION.EST) {\n    if (!mapTmp[currentPosition.x][currentPosition.y + 1]) return defaultReturn;\n    if (![\"0\", \"T\"].includes(mapTmp[currentPosition.x][currentPosition.y + 1][0])) return defaultReturn;\n    mapTmp[currentPosition.x][currentPosition.y] = currentPrevCase;\n    tmpHero = getPrevCase(mapTmp[currentPosition.x][currentPosition.y + 1], hero);\n    mapTmp[currentPosition.x][currentPosition.y + 1] = name;\n    return {\n      map: mapTmp,\n      newHeroStat: {\n        ...hero,\n        position: {\n          x: currentPosition.x,\n          y: currentPosition.y + 1\n        },\n        prevCase: newPrevCase\n      }\n    };\n  } else if (currentOrientation === ORIENTATION.OUEST) {\n    if (!mapTmp[currentPosition.x][currentPosition.y - 1]) return defaultReturn;\n    if (![\"0\", \"T\"].includes(mapTmp[currentPosition.x][currentPosition.y - 1][0])) return defaultReturn;\n    mapTmp[currentPosition.x][currentPosition.y] = currentPrevCase;\n    tmpHero = getPrevCase(mapTmp[currentPosition.x][currentPosition.y - 1], hero);\n    mapTmp[currentPosition.x][currentPosition.y - 1] = name;\n    return {\n      map: mapTmp,\n      newHeroStat: {\n        ...hero,\n        position: {\n          x: currentPosition.x,\n          y: currentPosition.y - 1\n        },\n        prevCase: newPrevCase\n      }\n    };\n  }\n  return defaultReturn;\n};\nexport const onMove = (currentMap, hero, move) => {\n  if (move === MOOVE.AVANCE) {\n    const {\n      map,\n      newHeroStat\n    } = moveHero(hero, currentMap);\n    return {\n      map: map,\n      newHeroStat\n    };\n  } else if (move === MOOVE.DROITE || move === MOOVE.GAUCHE) {\n    const orientation = changeOrientation(move, hero.orientation);\n    return {\n      map: currentMap,\n      newHeroStat: {\n        ...hero,\n        orientation\n      }\n    };\n  }\n  return {\n    map: currentMap,\n    newHeroStat: {\n      ...hero\n    }\n  };\n};","map":{"version":3,"names":["MOOVE","ORIENTATION","getPrevCase","current","hero","tmpHero","prevCase","includes","strNumber","slice","rest","treasure","changeOrientation","move","currentOrientation","orientation","GAUCHE","NORD","OUEST","SUD","EST","DROITE","moveHero","currentMap","mapTmp","position","currentPosition","currentPrevCase","name","defaultReturn","map","newHeroStat","newPrevCase","x","y","onMove","AVANCE"],"sources":["/Users/william/Desktop/Projets Code/entretient/map-resolver/src/utils/onMove.ts"],"sourcesContent":["import { MOOVE, ORIENTATION } from \"../type/enum\";\nimport { Hero, Pos } from \"../type/type\";\n\nconst getPrevCase = (current: string, hero: Hero) => {\n  let tmpHero = hero;\n  tmpHero.prevCase = current;\n  if (current.includes(\"T\")) {\n    if (current === \"T\") tmpHero.prevCase = \"0\";\n    else {\n      const strNumber = current.slice(1);\n      const rest = +strNumber - 1;\n\n      tmpHero.prevCase = rest === 0 ? \"0\" : `T${rest}`;\n    }\n    tmpHero.treasure += 1;\n  }\n\n  return tmpHero;\n};\n\nconst changeOrientation = (move: MOOVE, currentOrientation: ORIENTATION) => {\n  let orientation = currentOrientation;\n  if (move === MOOVE.GAUCHE) {\n    if (currentOrientation === ORIENTATION.NORD)\n      orientation = ORIENTATION.OUEST;\n    else if (currentOrientation === ORIENTATION.SUD)\n      orientation = ORIENTATION.EST;\n    else if (currentOrientation === ORIENTATION.EST)\n      orientation = ORIENTATION.NORD;\n    else if (currentOrientation === ORIENTATION.OUEST)\n      orientation = ORIENTATION.SUD;\n  } else if (move === MOOVE.DROITE) {\n    if (currentOrientation === ORIENTATION.NORD) orientation = ORIENTATION.EST;\n    else if (currentOrientation === ORIENTATION.SUD)\n      orientation = ORIENTATION.OUEST;\n    else if (currentOrientation === ORIENTATION.EST)\n      orientation = ORIENTATION.SUD;\n    else if (currentOrientation === ORIENTATION.OUEST)\n      orientation = ORIENTATION.NORD;\n  }\n  return orientation;\n};\n\nconst moveHero = (\n  hero: Hero,\n  currentMap: string[][]\n): { map: string[][]; newHeroStat: Hero } => {\n  let mapTmp = [...currentMap];\n  const {\n    position: currentPosition,\n    orientation: currentOrientation,\n    prevCase: currentPrevCase,\n    name,\n  } = hero;\n  const defaultReturn = {\n    map: currentMap,\n    newHeroStat: hero,\n  };\n  let newPrevCase: string;\n  let tmpHero = hero;\n\n  if (currentOrientation === ORIENTATION.NORD) {\n    if (!mapTmp[currentPosition.x - 1]) return defaultReturn;\n    if (\n      ![\"0\", \"T\"].includes(mapTmp[currentPosition.x - 1][currentPosition.y][0])\n    )\n      return defaultReturn;\n\n    mapTmp[currentPosition.x][currentPosition.y] = currentPrevCase;\n    tmpHero = getPrevCase(\n      mapTmp[currentPosition.x - 1][currentPosition.y],\n      hero\n    );\n    mapTmp[currentPosition.x - 1][currentPosition.y] = name;\n\n    return {\n      map: mapTmp,\n      newHeroStat: {\n        ...hero,\n        position: { x: currentPosition.x - 1, y: currentPosition.y },\n      },\n    };\n  } else if (currentOrientation === ORIENTATION.SUD) {\n    if (!mapTmp[currentPosition.x + 1]) return defaultReturn;\n    if (\n      ![\"0\", \"T\"].includes(mapTmp[currentPosition.x + 1][currentPosition.y][0])\n    )\n      return defaultReturn;\n\n    mapTmp[currentPosition.x][currentPosition.y] = currentPrevCase;\n    tmpHero = getPrevCase(\n      mapTmp[currentPosition.x + 1][currentPosition.y],\n      hero\n    );\n    mapTmp[currentPosition.x + 1][currentPosition.y] = name;\n\n    return {\n      map: mapTmp,\n      newHeroStat: {\n        ...hero,\n        position: { x: currentPosition.x + 1, y: currentPosition.y },\n      },\n    };\n  } else if (currentOrientation === ORIENTATION.EST) {\n    if (!mapTmp[currentPosition.x][currentPosition.y + 1]) return defaultReturn;\n    if (\n      ![\"0\", \"T\"].includes(mapTmp[currentPosition.x][currentPosition.y + 1][0])\n    )\n      return defaultReturn;\n\n    mapTmp[currentPosition.x][currentPosition.y] = currentPrevCase;\n    tmpHero = getPrevCase(\n      mapTmp[currentPosition.x][currentPosition.y + 1],\n      hero\n    );\n    mapTmp[currentPosition.x][currentPosition.y + 1] = name;\n\n    return {\n      map: mapTmp,\n      newHeroStat: {\n        ...hero,\n        position: { x: currentPosition.x, y: currentPosition.y + 1 },\n        prevCase: newPrevCase,\n      },\n    };\n  } else if (currentOrientation === ORIENTATION.OUEST) {\n    if (!mapTmp[currentPosition.x][currentPosition.y - 1]) return defaultReturn;\n    if (\n      ![\"0\", \"T\"].includes(mapTmp[currentPosition.x][currentPosition.y - 1][0])\n    )\n      return defaultReturn;\n\n    mapTmp[currentPosition.x][currentPosition.y] = currentPrevCase;\n    tmpHero = getPrevCase(\n      mapTmp[currentPosition.x][currentPosition.y - 1],\n      hero\n    );\n    mapTmp[currentPosition.x][currentPosition.y - 1] = name;\n\n    return {\n      map: mapTmp,\n      newHeroStat: {\n        ...hero,\n        position: { x: currentPosition.x, y: currentPosition.y - 1 },\n        prevCase: newPrevCase,\n      },\n    };\n  }\n\n  return defaultReturn;\n};\n\nexport const onMove = (\n  currentMap: string[][],\n  hero: Hero,\n  move: MOOVE\n): {\n  map: string[][];\n  newHeroStat: Hero;\n} => {\n  if (move === MOOVE.AVANCE) {\n    const { map, newHeroStat } = moveHero(hero, currentMap);\n    return {\n      map: map,\n      newHeroStat,\n    };\n  } else if (move === MOOVE.DROITE || move === MOOVE.GAUCHE) {\n    const orientation = changeOrientation(move, hero.orientation);\n    return {\n      map: currentMap,\n      newHeroStat: { ...hero, orientation },\n    };\n  }\n  return {\n    map: currentMap,\n    newHeroStat: { ...hero },\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}